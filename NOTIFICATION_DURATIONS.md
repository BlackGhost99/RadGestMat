# üìÖ GESTION DES NOTIFICATIONS PAR DUR√âE D'EMPRUNT

## Classification des emprunts

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ DUR√âE = date_retour_prevue - date_attribution              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  COURT TERME: 0 √† 4 heures           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Exemple: 14h00 ‚Üí 18h00               ‚îÇ
‚îÇ Rappels: AUCUN (trop court)          ‚îÇ
‚îÇ Alerte retard: Si > heure retour +30 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  MOYEN TERME: 4 √† 24 heures          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Exemple: 09h00 ‚Üí 18h00 (m√™me jour)  ‚îÇ
‚îÇ Exemple: 14h00 ‚Üí 14h00 (jour suivant)‚îÇ
‚îÇ Rappels: 1 rappel √† 2h avant retour  ‚îÇ
‚îÇ Alerte retard: Si > heure retour +30 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  LONG TERME: > 24 heures             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Exemple: 09h00 lundi ‚Üí 09h00 vendredi‚îÇ
‚îÇ Rappels: J-2, J-1 (10h du matin)    ‚îÇ
‚îÇ Alerte retard: Si > 10h du jour retour‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Mod√®le Attribution modifi√©

```python
# Ajouter √† Attribution:
DUREE_COURT_TERME = 'COURT'    # 0-4h
DUREE_MOYEN_TERME = 'MOYEN'    # 4h-24h
DUREE_LONG_TERME = 'LONG'      # >24h

DUREE_CHOICES = [
    (DUREE_COURT_TERME, 'Court terme (< 4h)'),
    (DUREE_MOYEN_TERME, 'Moyen terme (4h - 24h)'),
    (DUREE_LONG_TERME, 'Long terme (> 24h)'),
]

class Attribution(models.Model):
    # ... champs existants ...
    
    # NOUVEAU: Champs pour dur√©e d'emprunt
    duree_emprunt = models.CharField(
        max_length=10,
        choices=DUREE_CHOICES,
        default=DUREE_LONG_TERME,
        help_text="Cat√©gorie automatique bas√©e sur la dur√©e"
    )
    
    # NOUVEAU: Heures de retour (pour court/moyen terme)
    heure_retour_prevue = models.TimeField(
        null=True,
        blank=True,
        help_text="Heure de retour pr√©vue (pour emprunts < 24h)"
    )
    heure_retour_effective = models.TimeField(
        null=True,
        blank=True,
        help_text="Heure effective de retour"
    )
    
    def calculate_duree_emprunt(self):
        """Calcul automatique de la cat√©gorie de dur√©e"""
        if not self.date_retour_prevue:
            return self.DUREE_LONG_TERME
            
        # Conversion en datetime pour calcul pr√©cis
        from django.utils import timezone
        from datetime import datetime, time
        
        if isinstance(self.date_attribution, datetime):
            start = self.date_attribution
        else:
            start = datetime.combine(self.date_attribution, time.min)
        
        if self.heure_retour_prevue:
            end = datetime.combine(
                self.date_retour_prevue,
                self.heure_retour_prevue
            )
        else:
            end = datetime.combine(self.date_retour_prevue, time.min)
        
        delta = end - start
        hours = delta.total_seconds() / 3600
        
        if hours <= 4:
            return self.DUREE_COURT_TERME
        elif hours <= 24:
            return self.DUREE_MOYEN_TERME
        else:
            return self.DUREE_LONG_TERME
    
    def save(self, *args, **kwargs):
        # ... code existant ...
        
        # AUTO-CALCULER la dur√©e
        self.duree_emprunt = self.calculate_duree_emprunt()
        
        super().save(*args, **kwargs)
```

---

## Logique de notifications par dur√©e

### üü¢ **COURT TERME (0-4h)**

**√Ä la cr√©ation:**
- ‚úâÔ∏è EMAIL CLIENT: Confirmation rapide
- Pas de rappel (trop court)

**Monitoring:**
```python
# V√©rifier chaque 15 min si heure_retour_effective == heure_retour_prevue
# Seuil: +30 minutes ‚Üí ALERTE RETARD

if datetime.now() > heure_retour_prevue + 30min AND date_retour_effective == NULL:
    ‚Üí ALERTE CLIENT + MANAGER
```

**√Ä la restitution:**
- ‚úâÔ∏è EMAIL: Confirmation restitution

---

### üü° **MOYEN TERME (4h-24h)**

**√Ä la cr√©ation:**
- ‚úâÔ∏è EMAIL CLIENT: D√©tails complets
- üí¨ WHATSAPP: Confirmation br√®ve

**Rappel unique:**
```python
# 2 heures avant heure_retour_prevue

timestamp_rappel = datetime.combine(
    date_retour_prevue,
    heure_retour_prevue
) - timedelta(hours=2)

scheduler.add_job(
    send_reminder_notification,
    trigger='date',
    run_date=timestamp_rappel,
    args=[attribution_id]
)
```

**Monitoring:**
```python
# V√©rifier chaque 30 min
if datetime.now() > heure_retour_prevue + 30min AND date_retour_effective == NULL:
    ‚Üí ALERTE RETARD (CLIENT + MANAGER)
```

---

### üîµ **LONG TERME (>24h)**

**√Ä la cr√©ation:**
- ‚úâÔ∏è EMAIL CLIENT: D√©tails + conditions
- üí¨ WHATSAPP: Info retour pr√©vu

**Rappels multiples:**
```python
# J-2 √† 10h
scheduler.add_job(
    send_reminder_notification,
    trigger='date',
    run_date=datetime.combine(date_retour_prevue - 2 days, time(10, 0)),
    args=[attribution_id, 'RAPPEL_J_MOINS_2']
)

# J-1 √† 10h
scheduler.add_job(
    send_reminder_notification,
    trigger='date',
    run_date=datetime.combine(date_retour_prevue - 1 day, time(10, 0)),
    args=[attribution_id, 'RAPPEL_J_MOINS_1']
)

# Jour retour √† 08h (rappel final)
scheduler.add_job(
    send_reminder_notification,
    trigger='date',
    run_date=datetime.combine(date_retour_prevue, time(8, 0)),
    args=[attribution_id, 'RAPPEL_FINAL']
)
```

**Monitoring (quotidien √† 14h):**
```python
# Chercher les attributions en retard
overdue_attributions = Attribution.objects.filter(
    date_retour_prevue__lt=today(),
    date_retour_effective__isnull=True
)

for attr in overdue_attributions:
    days_late = (today() - attr.date_retour_prevue).days
    
    if days_late == 0:
        severite = CRITICAL  # Jour m√™me du retour
    elif days_late <= 3:
        severite = WARNING   # Moins de 3 jours
    else:
        severite = CRITICAL  # Plus de 3 jours
    
    create_alert(attr, severite, days_late)
```

---

## Mod√®le NotificationLog am√©lior√©

```python
class NotificationLog(models.Model):
    TYPE_CREATION = 'CREATION'
    TYPE_RAPPEL_2H = 'RAPPEL_2H'
    TYPE_RAPPEL_J_MOINS_2 = 'RAPPEL_J_MOINS_2'
    TYPE_RAPPEL_J_MOINS_1 = 'RAPPEL_J_MOINS_1'
    TYPE_RAPPEL_FINAL = 'RAPPEL_FINAL'
    TYPE_RETARD = 'RETARD'
    TYPE_RESTITUTION = 'RESTITUTION'
    
    TYPE_CHOICES = [
        (TYPE_CREATION, 'Notification de cr√©ation'),
        (TYPE_RAPPEL_2H, 'Rappel 2h avant'),
        (TYPE_RAPPEL_J_MOINS_2, 'Rappel J-2'),
        (TYPE_RAPPEL_J_MOINS_1, 'Rappel J-1'),
        (TYPE_RAPPEL_FINAL, 'Rappel jour retour'),
        (TYPE_RETARD, 'Alerte retard'),
        (TYPE_RESTITUTION, 'Confirmation restitution'),
    ]
    
    CANAL_EMAIL = 'EMAIL'
    CANAL_WHATSAPP = 'WHATSAPP'
    CANAL_CHOICES = [
        (CANAL_EMAIL, 'Email'),
        (CANAL_WHATSAPP, 'WhatsApp'),
    ]
    
    STATUT_ENVOYEE = 'ENVOYEE'
    STATUT_ECHEC = 'ECHEC'
    STATUT_ECHEC_PERMANENT = 'ECHEC_PERM'
    STATUT_CHOICES = [
        (STATUT_ENVOYEE, 'Envoy√©e'),
        (STATUT_ECHEC, '√âchec (retry en cours)'),
        (STATUT_ECHEC_PERMANENT, '√âchec d√©finitif'),
    ]
    
    attribution = models.ForeignKey(Attribution, on_delete=models.CASCADE)
    type_notification = models.CharField(max_length=20, choices=TYPE_CHOICES)
    canal = models.CharField(max_length=20, choices=CANAL_CHOICES)
    duree_emprunt = models.CharField(max_length=10)  # Snapshot de la dur√©e
    destinataire = models.CharField(max_length=200)  # email ou t√©l√©phone
    statut = models.CharField(max_length=20, choices=STATUT_CHOICES, default=STATUT_ENVOYEE)
    message_id = models.CharField(max_length=255, blank=True, null=True)
    date_envoi = models.DateTimeField(auto_now_add=True)
    date_scheduled = models.DateTimeField(null=True, blank=True)  # Quand √©tait-ce pr√©vu?
    date_tentative_prochaine = models.DateTimeField(null=True, blank=True)
    erreur_message = models.TextField(blank=True, null=True)
    nb_tentatives = models.IntegerField(default=1)
    
    class Meta:
        verbose_name = "Notification"
        verbose_name_plural = "Notifications"
        ordering = ['-date_envoi']
        indexes = [
            models.Index(fields=['attribution', 'type_notification']),
            models.Index(fields=['statut', 'date_tentative_prochaine']),
        ]
```

---

## Timeline compar√©e

### üìä Emprunt court-terme (14h ‚Üí 18h, 4h)

```
14:00 Cr√©ation
‚îú‚îÄ 14:00 ‚úâÔ∏è EMAIL "Mat√©riel emprunt√©"
‚îú‚îÄ 14:05 üí¨ WHATSAPP "Confirm√©"
‚îÇ
18:00 Check-in attendu
‚îú‚îÄ 18:00 [Monitoring]
‚îú‚îÄ 18:30 ‚ö†Ô∏è ALERTE RETARD (si pas retourn√©)
‚îÇ        ‚úâÔ∏è EMAIL URGENT
‚îÇ        üí¨ WHATSAPP URGENT
‚îÇ
19:00 [Monitoring]
‚îú‚îÄ 19:00 ‚ö†Ô∏è ESCALADE si toujours pas retourn√©
‚îÇ
...
```

### üìä Emprunt moyen-terme (09h lundi ‚Üí 18h lundi, 9h)

```
09:00 Cr√©ation (lundi)
‚îú‚îÄ 09:00 ‚úâÔ∏è EMAIL "Mat√©riel emprunt√©"
‚îú‚îÄ 09:05 üí¨ WHATSAPP "Confirm√©"
‚îÇ
16:00 Rappel (2h avant 18h)
‚îú‚îÄ 16:00 ‚úâÔ∏è EMAIL "Retour dans 2h"
‚îú‚îÄ 16:05 üí¨ WHATSAPP "Retour 18h?"
‚îÇ
18:00 Check-in attendu
‚îú‚îÄ 18:00 [Monitoring]
‚îú‚îÄ 18:30 ‚ö†Ô∏è ALERTE RETARD
‚îÇ        ‚úâÔ∏è EMAIL URGENT
‚îÇ        üí¨ WHATSAPP URGENT
‚îÇ
...
```

### üìä Emprunt long-terme (09h lundi ‚Üí 09h vendredi, 4 jours)

```
09:00 Cr√©ation (lundi)
‚îú‚îÄ 09:00 ‚úâÔ∏è EMAIL "Mat√©riel emprunt√© - retour vendredi"
‚îú‚îÄ 09:05 üí¨ WHATSAPP "Confirm√©"
‚îÇ
10:00 Mercredi (J-2)
‚îú‚îÄ 10:00 ‚úâÔ∏è EMAIL "Rappel: 2 jours restants"
‚îú‚îÄ 10:05 üí¨ WHATSAPP "Rappel J-2"
‚îÇ
10:00 Jeudi (J-1)
‚îú‚îÄ 10:00 ‚úâÔ∏è EMAIL "Rappel: Retour demain!"
‚îú‚îÄ 10:05 üí¨ WHATSAPP "Retour demain?"
‚îÇ
08:00 Vendredi (Jour retour)
‚îú‚îÄ 08:00 ‚úâÔ∏è EMAIL "Rappel final: retour aujourd'hui avant 17h"
‚îú‚îÄ 08:05 üí¨ WHATSAPP "Dernier jour!"
‚îÇ
09:00 Vendredi
‚îú‚îÄ 09:00 [Monitoring]
‚îÇ
14:00 Vendredi (5h apr√®s)
‚îú‚îÄ 14:00 ‚ö†Ô∏è ALERTE RETARD
‚îÇ        ‚úâÔ∏è EMAIL URGENT (Client + Manager)
‚îÇ        üí¨ WHATSAPP URGENT
‚îÇ
...
```

---

## Service NotificationService v2

```python
class NotificationService:
    """Service unifi√© pour g√©rer les notifications selon la dur√©e d'emprunt"""
    
    def __init__(self):
        self.email_service = EmailNotificationService()
        self.whatsapp_service = WhatsAppNotificationService()
    
    def on_attribution_created(self, attribution):
        """D√©clench√© quand une attribution est cr√©√©e"""
        duree = attribution.duree_emprunt
        
        # Toujours: Notification cr√©ation
        self._notify(attribution, NotificationLog.TYPE_CREATION)
        
        # Planifier les rappels selon dur√©e
        if duree == Attribution.DUREE_COURT_TERME:
            self._schedule_monitoring_court_terme(attribution)
        
        elif duree == Attribution.DUREE_MOYEN_TERME:
            self._schedule_rappel_2h(attribution)
            self._schedule_monitoring_moyen_terme(attribution)
        
        elif duree == Attribution.DUREE_LONG_TERME:
            self._schedule_rappels_long_terme(attribution)
    
    def _notify(self, attribution, type_notif, canal=None):
        """Envoyer notification imm√©diate"""
        # V√©rifier les pr√©f√©rences
        # D√©terminer canaux (email/whatsapp)
        # Envoyer via services appropri√©s
        pass
    
    def _schedule_rappel_2h(self, attribution):
        """Planifier rappel 2h avant pour moyen terme"""
        rappel_time = datetime.combine(
            attribution.date_retour_prevue,
            attribution.heure_retour_prevue
        ) - timedelta(hours=2)
        
        scheduler.add_job(
            self._notify,
            trigger='date',
            run_date=rappel_time,
            args=[attribution, NotificationLog.TYPE_RAPPEL_2H]
        )
    
    def _schedule_rappels_long_terme(self, attribution):
        """Planifier 3 rappels pour long terme"""
        # J-2 √† 10h
        # J-1 √† 10h
        # Jour retour √† 8h
        pass
    
    def check_overdue_court_terme(self):
        """Appel chaque 15 min pour court terme"""
        attributions = Attribution.objects.filter(
            duree_emprunt=Attribution.DUREE_COURT_TERME,
            date_retour_effective__isnull=True
        )
        
        for attr in attributions:
            prevue = datetime.combine(
                attr.date_retour_prevue,
                attr.heure_retour_prevue
            )
            
            if datetime.now() > prevue + timedelta(minutes=30):
                self._notify(attr, NotificationLog.TYPE_RETARD, urgence=True)
    
    def check_overdue_moyen_terme(self):
        """Appel chaque 30 min pour moyen terme"""
        # Similaire √† court terme
        pass
    
    def check_overdue_long_terme(self):
        """Appel quotidien (14h) pour long terme"""
        # V√©rifier attributions avec date_retour < aujourd'hui
        # Cr√©er alertes appropri√©es
        pass
```

---

## Variables d'environnement .env

```bash
# Notifications - Fr√©quences
NOTIFICATION_CHECK_COURT_TERME_MINUTES=15    # 15 min
NOTIFICATION_CHECK_MOYEN_TERME_MINUTES=30    # 30 min
NOTIFICATION_CHECK_LONG_TERME_HOUR=14        # 14h (quotidien)

# Seuils de retard
NOTIFICATION_RETARD_SEUIL_COURT_TERME=30     # 30 min apr√®s heure pr√©vue
NOTIFICATION_RETARD_SEUIL_MOYEN_TERME=60     # 60 min apr√®s heure pr√©vue
NOTIFICATION_RETARD_SEUIL_LONG_TERME=14400   # 4h apr√®s heure pr√©vue (10h)

# Twilio
TWILIO_ACCOUNT_SID=...
TWILIO_AUTH_TOKEN=...
TWILIO_PHONE_NUMBER=...

# Email
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=your-email@gmail.com
EMAIL_HOST_PASSWORD=your-app-password
DEFAULT_FROM_EMAIL=your-email@gmail.com
```

---

## R√©sum√© des changements mod√®le

```python
# DANS Attribution:

# AJOUTS:
duree_emprunt = CharField(choices=DUREE_CHOICES)  # AUTO
heure_retour_prevue = TimeField(null=True)        # OPTIONNEL
heure_retour_effective = TimeField(null=True)     # AUTO

# M√âTHODES:
def calculate_duree_emprunt()  # Calcul automatique
def get_notification_schedule() # Retourne tous les rappels planifi√©s
def check_retard()              # V√©rifier si en retard
```

‚úÖ **Avantages:**
- Gestion fine des 3 dur√©es sans code redondant
- Rappels adaptatifs (aucun pour <4h, 1 pour 4-24h, 3+ pour >24h)
- Monitoring adapt√© √† chaque type
- Alertes gradu√©es selon s√©v√©rit√©

